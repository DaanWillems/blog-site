<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="Small summary">  

  <title>
    
      Building a database: Getting Started
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.18e297f9c7b534b566a0a070712181cc69b4f1155e1b8d1fe541304605c4f6ab7d7460a557a004bf67fd09787aef348cf619f6dd8d310362898a41b1465ddd4d.css" integrity="sha512-GOKX&#43;ce1NLVmoKBwcSGBzGm08RVeG40f5UEwRgXE9qt9dGClV6AEv2f9CXh67zSM9hn23Y0xA2KJikGxRl3dTQ==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
                <div class="post-meta">
                    <a href="/">..</a>

                    <p>
                        <time datetime="2025-04-24 00:00:00 &#43;0000 UTC">
                            2025-04-24
                        </time>
                    </p>
                </div>

<article>
    <h1>Building a database: Getting Started</h1>

    
        <aside >
            <nav id="TableOfContents">
  <ul>
    <li><a href="#requirements">Requirements</a></li>
    <li><a href="#storing-data-on-disk">Storing data on disk</a>
      <ul>
        <li><a href="#sstables-and-b-trees">SSTables and B-Trees</a></li>
        <li><a href="#sstables">SSTables</a></li>
        <li><a href="#compaction">Compaction</a></li>
        <li><a href="#blocks">Blocks</a></li>
      </ul>
    </li>
    <li><a href="#designing-the-database">Designing the database</a>
      <ul>
        <li><a href="#inserting-data">Inserting data</a></li>
        <li><a href="#updating-data">Updating data</a></li>
        <li><a href="#reading-data">Reading data</a></li>
        <li><a href="#deleting-data">Deleting data</a></li>
      </ul>
    </li>
    <li><a href="#a-first-implementation">A first implementation</a>
      <ul>
        <li><a href="#memtables">Memtables</a></li>
        <li><a href="#serializing-entries">Serializing entries</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </aside>
    

    <p>In almost every project I ever built, a database was a central component. Often I&rsquo;d read online about what specific database engines excelled in, and what they lacked. However, I never fully understood what this meant exactly. That always irritated me. I think in cases like this, the best way to learn more about a topic is to try build something myself. So I set out with very little knowledge but a lot of optimism to try to build my own database engine.</p>
<p>This post is the first part of building a simple database engine from scratch. It covers:</p>
<ul>
<li>Requirements for a simple database</li>
<li>How to store data on disk</li>
<li>Key components of a database engine (WAL, Memtable, SSTables)</li>
<li>First steps in implementation (in Go)</li>
</ul>
<p>In follow up posts I will try and optimize the database and also expand upon its functionality.</p>
<h2 id="requirements">Requirements</h2>
<p>Before starting with anything, it is important to determine the database requirements. Clear requirements can direct the design while also preventing unnecessary work.</p>
<ul>
<li>Data written must be persistent (not lost on system restarts)</li>
<li>The database must be crash resistant</li>
<li>There should be some sort of schema to define what the data looks like</li>
<li>It must support: strings, integers and booleans.</li>
<li>It must support: Defining a primary key</li>
<li>There should be a way of interfacing with the database (inserting, reading, updating and deleting data)</li>
<li>There should be a primary index to speed up finding data</li>
<li>The database should be optimized for quick writes</li>
</ul>
<p>Out of scope:</p>
<ul>
<li>Relations between data (so no joins)</li>
<li>No secondary indexes (Indexes on fields other than the primary key)</li>
<li>Ability to update existing table structures</li>
</ul>
<h2 id="storing-data-on-disk">Storing data on disk</h2>
<p>A core part of a database is being able to store data persistently (on disk) and being able to search it. In this section</p>
<h3 id="sstables-and-b-trees">SSTables and B-Trees</h3>
<p>There are many ways of achieving this. Modern databases often use one of two data structures to store data: B-Trees or SSTables. While B-Trees are very good at searching through the data quickly, is it complicated to store a B-Tree on disk. SSTables excel at writing quickly, but are less optmized for reading. SSTables are used to power popular databases like CassandraDB and Lucene (Elasticsearch). B-Tree&rsquo;s are often used in relational databases where reading is very important, like PostgresQL and MySQL. For this project we will use SStables.</p>
<h3 id="sstables">SSTables</h3>
<p>SSTables work by building a sorted string table on disk. When data is written to the database, it is initially stored in an in memory data structure. When the in memory data structure reaches a certain size, it is written to disk as an SSTable. The SSTable is immutable,and cannot be updated. This means mutations on existed records must be written to a new SStable. Altered records can be added to a new SStable, deleted records are also added, and tombstoned (marked as deleted).</p>
<p>Imagine a key value table written stored on disk. It includes a delete</p>
<p>Table 1:</p>
<pre tabindex="0"><code>Key, Deleted, Value

1, False, &#34;a&#34;
2, False, &#34;b&#34;
3, False, &#34;c&#34;
6, False, &#34;d&#34;
</code></pre><p>At this point the user adds the record (4, &lsquo;a2&rsquo;), removed the record with id 2 and update the record 6 to value &lsquo;d2&rsquo;. These changes are written to a new table on disk:</p>
<p>Table 2:</p>
<pre tabindex="0"><code>Key, Deleted, Value

2, True,  &#34;b&#34;
4, False, &#34;a2&#34;
6, False, &#34;d2&#34;
</code></pre><p>When the database is queried, we first look into table 2, and then table 1. This ensures the database always returns the most up to date information. A downside of this approach is that if a key is queried that is not in the database, all tables will have to be searched.</p>
<h3 id="compaction">Compaction</h3>
<p>With the SSTables method of storing data, a lot of potential duplication is introduced. In order to mitigate this, tables are compacted in the background over time. For example, the two tables above could be compacted into the following single table:</p>
<p>Table 3:</p>
<pre tabindex="0"><code>Key, Deleted, Value

1, False, &#34;a&#34;
3, False, &#34;c&#34;
4, False, &#34;a2&#34;
6, False, &#34;2&#34;
</code></pre><p>By using a merge sort, it is efficient to merge 2 sorted lists into 1 sorted list.</p>
<p>SSTables enable quick writes, as the database only ever has to append to a file, which is much quicker than writing to a file in random location.</p>
<h3 id="blocks">Blocks</h3>
<p>It&rsquo;s impossible to predict the length of an entry, it depends on what the user is storing. This means that if multiple entries are written to a SSTable, we cannot know where entries start and end without scanning the file from the beginning. A common practice is to structure the SSTable into blocks. By dividing the table into blocks of predictable size, we open the door for many possible search optimizations. Let&rsquo;s investigate how these blocks are structured.</p>
<p>First we determine a static size for each block, usually that will be something like 2MB. We adhere to the following rules when writing to block:</p>
<ul>
<li>Each block always starts with a new entry to ensure entries are never split across block boundaries.</li>
<li>If an entry cannot be added to a block without exceeding the remaining space in the block, the entry is added to a new block. The current block is padded with 0 bytes. Padding is important because we want blocks of fixed size, but also wastes some space on disk.</li>
<li>To keep things simple: if an entry is larger than the block size, it will never fit. The database will throw an error.</li>
</ul>
<p>Let&rsquo;s say we have an entry that is 6 bytes long. It&rsquo;s added to the first block:</p>
<p>Todo: make image</p>
<p>We add another entry of 6 bytes. As the remaining size in the block is: 10-6=4, the entry is added to a new block.</p>
<p>Todo: make image</p>
<p>In a later part, we can use the predictable block structure to build a binary search algorithm</p>
<h2 id="designing-the-database">Designing the database</h2>
<p>The database will consist of the following parts:</p>
<ul>
<li>
<p>A memory table that is used to store recent operations on the database</p>
</li>
<li>
<p>A WAL (Write Ahead Log) to guarantee persistence of the memory table in case the computer shuts down</p>
</li>
<li>
<p>SSTables that store ordered rows.</p>
</li>
</ul>
<p>When a user inserts a new record, the actions is written to the WAL and inserted into the memory table (memtable). The memory table is ordered by the primary key, but the WAL is ordered by time. As more data is inserted over time, the memtable grows. When it has reached a certain size (2MB). The table is written to a SSTable on disk. When the SSTable has reached some predefined size, it is closed and a new SSTable can be created.</p>
<p><img src="/images/db_design.png" alt="Image displaying database design"></p>
<p>Each table in the database is given a separate directory with sstables, but all database commands are stored in the same memtable and WAL. The table structures (or schema) can be stored in its own table.</p>
<h3 id="inserting-data">Inserting data</h3>
<p>If a user inserts a record, we write the insertion to the WAL and insert the row in the memtable in its appropriate ordered location.</p>
<h3 id="updating-data">Updating data</h3>
<p>If a user updates a record, we update the data in the memtable, but if the record is not in there (because it&rsquo;s been flushed to disk) it is simply added to the memtable as if it is an insertion.</p>
<h3 id="reading-data">Reading data</h3>
<p>When a user queries a specific primary key, the database engine searches the memtable. If it isn&rsquo;t there it then starts to search the most recent SSTable and all following SSTables until it finds it. This means that if the key is not in the database the process has to search everything. This part can be sped up by an indexing strategy.</p>
<h3 id="deleting-data">Deleting data</h3>
<p>Like updating we update the record by setting a deleted flag to true</p>
<h2 id="a-first-implementation">A first implementation</h2>
<p>Let&rsquo;s start implementing some of the basic building blocks of the database. I have decided to use Golang as I&rsquo;m familiar with it and it&rsquo;s simple to write.</p>
<h3 id="memtables">Memtables</h3>
<p>First we implement the memtable component. We need the memtable to be able to support different types of tables later on, so let&rsquo;s design it with that in mind.</p>
<p>We&rsquo;ll maintain an ordered list of entries. Each entry has a primary key, a deleted flag and a list of values. Depending on the table structure, the primary key might be a a string, int or bool. The values can also be any type. In order to support this the primary key and values with be stored as byte arrays. The database can then look into the table structure to determine how to interpret the values. In order to maintain an</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Memtable</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">entries</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">list</span>.<span style="color:#a6e22e">List</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MemtableEntry</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">id</span>      []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">values</span>  [][]<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">deleted</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The memtable has functions for insert / update / get</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Memtable</span>) <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">id</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">MemtableEntry</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">entries</span>.<span style="color:#a6e22e">Front</span>(); <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>; <span style="color:#a6e22e">e</span> = <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Next</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Next</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Equal</span>(<span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">Value</span>.(<span style="color:#a6e22e">MemtableEntry</span>).<span style="color:#a6e22e">id</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">entry</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">Value</span>.(<span style="color:#a6e22e">MemtableEntry</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">entry</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Memtable</span>) <span style="color:#a6e22e">Update</span>(<span style="color:#a6e22e">id</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">values</span> [][]<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">entry</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MemtableEntry</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">id</span>:      <span style="color:#a6e22e">id</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">values</span>:  <span style="color:#a6e22e">values</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">deleted</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">entries</span>.<span style="color:#a6e22e">Front</span>(); <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>; <span style="color:#a6e22e">e</span> = <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Next</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Equal</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Value</span>.(<span style="color:#a6e22e">MemtableEntry</span>).<span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">id</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Value</span> = <span style="color:#a6e22e">entry</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Memtable</span>) <span style="color:#a6e22e">Insert</span>(<span style="color:#a6e22e">id</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">values</span> [][]<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">entry</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MemtableEntry</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">id</span>:      <span style="color:#a6e22e">id</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">values</span>:  <span style="color:#a6e22e">values</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">deleted</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">entries</span>.<span style="color:#a6e22e">Front</span>(); <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>; <span style="color:#a6e22e">e</span> = <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Next</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Next</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Compare</span>(<span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">Value</span>.(<span style="color:#a6e22e">MemtableEntry</span>).<span style="color:#a6e22e">id</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">entries</span>.<span style="color:#a6e22e">InsertBefore</span>(<span style="color:#a6e22e">entry</span>, <span style="color:#a6e22e">next</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">entries</span>.<span style="color:#a6e22e">PushBack</span>(<span style="color:#a6e22e">entry</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="serializing-entries">Serializing entries</h3>
<p>In order to store the data on disk and in the WAL the data needs to be serialized. We&rsquo;ll convert an entry into a byte array with the following format:</p>
<p>size, id_size, id_value, deleted, value_count, value_1_size, value_1. value_2_size, value_2&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">entry</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MemtableEntry</span>) <span style="color:#a6e22e">Serialize</span>() (<span style="color:#66d9ef">int</span>, []<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">content_bytes</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">byte</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">bytes</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">byte</span>{byte(len(<span style="color:#a6e22e">entry</span>.<span style="color:#a6e22e">id</span>))}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">bytes</span> = append(<span style="color:#a6e22e">bytes</span>, <span style="color:#a6e22e">entry</span>.<span style="color:#a6e22e">id</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">entry</span>.<span style="color:#a6e22e">deleted</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">content_bytes</span> = append(<span style="color:#a6e22e">content_bytes</span>, byte(<span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">content_bytes</span> = append(<span style="color:#a6e22e">content_bytes</span>, byte(<span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">content_bytes</span> = append(<span style="color:#a6e22e">content_bytes</span>, byte(len(<span style="color:#a6e22e">entry</span>.<span style="color:#a6e22e">values</span>)))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">entry</span>.<span style="color:#a6e22e">values</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">content_bytes</span> = append(<span style="color:#a6e22e">content_bytes</span>, byte(int(len(<span style="color:#a6e22e">v</span>))))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">content_bytes</span> = append(<span style="color:#a6e22e">content_bytes</span>, []byte(<span style="color:#a6e22e">v</span>)<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bytes</span> = append(<span style="color:#a6e22e">bytes</span>, byte(len(<span style="color:#a6e22e">content_bytes</span>)))
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bytes</span> = append(<span style="color:#a6e22e">bytes</span>, <span style="color:#a6e22e">content_bytes</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">bytes</span>), <span style="color:#a6e22e">bytes</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To read it back into the data structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">entry</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MemtableEntry</span>) <span style="color:#a6e22e">Deserialize</span>(<span style="color:#a6e22e">bytes</span> []<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">index</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">id_size</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">bytes</span>[<span style="color:#a6e22e">index</span>])
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">entry</span>.<span style="color:#a6e22e">id</span> = <span style="color:#a6e22e">bytes</span>[<span style="color:#a6e22e">index</span>:<span style="color:#a6e22e">index</span><span style="color:#f92672">+</span><span style="color:#a6e22e">id_size</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">index</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">id_size</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">index</span><span style="color:#f92672">++</span> <span style="color:#75715e">// We can skip the total content length</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">deleted_i</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">bytes</span>[<span style="color:#a6e22e">index</span>])
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">entry</span>.<span style="color:#a6e22e">deleted</span> = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">deleted_i</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">entry</span>.<span style="color:#a6e22e">deleted</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">values_count</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">bytes</span>[<span style="color:#a6e22e">index</span>])
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">values_count</span> {
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">size</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">bytes</span>[<span style="color:#a6e22e">index</span>])
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">byte</span>{}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">size</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">value</span> = append(<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">bytes</span>[<span style="color:#a6e22e">index</span>])
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">entry</span>.<span style="color:#a6e22e">values</span> = append(<span style="color:#a6e22e">entry</span>.<span style="color:#a6e22e">values</span>, <span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To test whether the serialization is working, we write some unit tests.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestSerializeDeserializeStr</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MemtableEntry</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">id</span>:      []byte(<span style="color:#e6db74">&#34;abc&#34;</span>),
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">values</span>:  [][]<span style="color:#66d9ef">byte</span>{[]byte(<span style="color:#e6db74">&#34;a&#34;</span>), []byte(<span style="color:#e6db74">&#34;b&#34;</span>)},
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">deleted</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Serialize</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">e1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MemtableEntry</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">e1</span>.<span style="color:#a6e22e">Deserialize</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">DeepEqual</span>(<span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">e1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Deserialized struct does not match original.\n Expected \n%v \n got \n%v&#34;</span>, <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">e1</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestSerializeDeserialize</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MemtableEntry</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">id</span>:      []<span style="color:#66d9ef">byte</span>{byte(<span style="color:#ae81ff">9</span>)},
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">values</span>:  [][]<span style="color:#66d9ef">byte</span>{[]byte(<span style="color:#e6db74">&#34;a&#34;</span>), []byte(<span style="color:#e6db74">&#34;b&#34;</span>)},
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">deleted</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Serialize</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">e1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MemtableEntry</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">e1</span>.<span style="color:#a6e22e">Deserialize</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">DeepEqual</span>(<span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">e1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Deserialized struct does not match original.\n Expected \n%v \n got \n%v&#34;</span>, <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">e1</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>SSTables</p>
<p>When the memtable is full, we want to store it to disk. This is where the SSTable comes in.</p>

</article>

            </div>
        </main>
    </body></html>
